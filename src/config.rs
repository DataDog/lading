//! This module controls configuration parsing from the end user, providing a
//! convenience mechanism for the rest of the program. Crashes are most likely
//! to originate from this code, intentionally.
use byte_unit::{Byte, ByteError};
use serde::Deserialize;
use std::collections::HashMap;
use std::convert::TryFrom;
use std::iter::Iterator;
use std::num::{NonZeroU32, TryFromIntError};
use std::path::PathBuf;
use std::str;

/// Main configuration struct for this program
#[derive(Debug, Deserialize)]
pub struct Config {
    /// The random seed that this program will populate its rng with
    pub random_seed: u64,
    /// Total number of worker threads to use in this program
    pub worker_threads: u16,
    /// The [`LogTargetTemplate`] instances and their base name
    pub targets: HashMap<String, LogTargetTemplate>,
}

/// Variant of the [`LogTarget`]
///
/// This variant controls what kind of line text is created by this program.
#[derive(Debug, Deserialize, Copy, Clone)]
pub enum Variant {
    /// Generates a constant ascii char
    Constant,
    /// Generates a line of printable ascii characters
    Ascii,
    /// Generates a json encoded line
    Json,
}

/// The template from which to create [`LogTarget`] instances
#[derive(Debug, Deserialize)]
pub struct LogTargetTemplate {
    /// The path template for [`LogTarget`]. "%NNN%" will be replaced in the
    /// template with the duplicate number.
    pub path_template: String,
    /// Total number of duplicates to make from this template.
    pub duplicates: u8,
    /// Sets the [`Variant`] of this template.
    pub variant: Variant,
    /// Sets the **soft** maximum bytes to be written into the `LogTarget`. This
    /// limit is soft, meaning a burst may go beyond this limit by no more than
    /// `maximum_token_burst`.
    ///
    /// After this limit is breached the target is closed and deleted. A new
    /// target with the same name is created to be written to.
    maximum_bytes_per_file: String,
    /// Defines the number of bytes that are added into the `LogTarget`'s rate
    /// limiting mechanism per second. This sets the maximum bytes that can be
    /// written _continuously_ per second from this target. Higher bursts are
    /// possible as the internal governor accumulates, up to
    /// `maximum_bytes_burst`.
    bytes_per_second: String,
    maximum_line_size_bytes: String,
}

/// The [`LogTarget`] is generated by [`LogTargetTemplate`]
#[derive(Debug)]
pub struct LogTarget {
    /// The path for this target
    pub path: PathBuf,
    /// Sets the [`Variant`] of this target
    pub variant: Variant,
    /// Sets the **soft** maximum bytes to be written into the `LogTarget`. This
    /// limit is soft, meaning a burst may go beyond this limit by no more than
    /// `maximum_token_burst`.
    ///
    /// After this limit is breached the target is closed and deleted. A new
    /// target with the same name is created to be written to.
    pub maximum_bytes_per_file: NonZeroU32,
    /// Defines the number of bytes that are added into the `LogTarget`'s rate
    /// limiting mechanism per second. This sets the maximum bytes that can be
    /// written _continuously_ per second from this target. Higher bursts are
    /// possible as the internal governor accumulates, up to
    /// `maximum_bytes_burst`.
    pub bytes_per_second: NonZeroU32,
    /// The maximum size in bytes that a line may be. This program may generate
    /// lines of less size.
    pub maximum_line_size_bytes: NonZeroU32,
}

/// Configuration errors
#[derive(Debug)]
pub enum Error {
    /// User provided a byte string that could not be decoded
    ByteError(ByteError),
    /// User provided a string that could not be decoded into an integer
    TryFromInt(TryFromIntError),
}

impl From<ByteError> for Error {
    fn from(error: ByteError) -> Self {
        Error::ByteError(error)
    }
}

impl From<TryFromIntError> for Error {
    fn from(error: TryFromIntError) -> Self {
        Error::TryFromInt(error)
    }
}

impl Iterator for LogTargetTemplateIter {
    type Item = LogTarget;

    fn next(&mut self) -> Option<Self::Item> {
        if self.current_duplicate >= self.duplicates {
            return None;
        }

        let duplicate = format!("{}", self.current_duplicate);
        let full_path = self.path_template.replace("%NNN%", &duplicate);

        let path = PathBuf::from(full_path);

        self.current_duplicate += 1;

        Some(LogTarget {
            path,
            variant: self.variant,
            maximum_bytes_per_file: self.maximum_bytes_per_file,
            bytes_per_second: self.bytes_per_second,
            maximum_line_size_bytes: self.maximum_line_size_bytes,
        })
    }
}

/// The iterator for [`LogTargetTemplate`]
#[derive(Debug)]
pub struct LogTargetTemplateIter {
    path_template: String,
    duplicates: usize,
    current_duplicate: usize,
    variant: Variant,
    maximum_bytes_per_file: NonZeroU32,
    bytes_per_second: NonZeroU32,
    maximum_line_size_bytes: NonZeroU32,
}

impl LogTargetTemplate {
    /// Convert this template into a [`LogTargetTemplateIter`]
    ///
    /// # Errors
    ///
    /// This conversion will fail if the configuration file provided by the user
    /// is not valid.
    pub fn iter(self) -> Result<LogTargetTemplateIter, Error> {
        Ok(LogTargetTemplateIter {
            path_template: self.path_template.clone(),
            current_duplicate: 0,
            duplicates: self.duplicates as usize,
            variant: self.variant,
            maximum_bytes_per_file: self.maximum_bytes_per_file()?,
            bytes_per_second: self.bytes_per_second()?,
            maximum_line_size_bytes: self.maximum_line_size_bytes()?,
        })
    }

    /// Determine the `maximum_line_size_bytes` for this [`LogTargetTemplate`]
    ///
    /// Parses the user's supplied stringy number into a non-zero u32 of bytes.
    ///
    /// # Errors
    ///
    /// If the users supplies anything other than a stringy number plus some
    /// recognizable unit this function will return an error. Likewise if the
    /// user supplies a number that is larger than `u32::MAX` bytes this
    /// function will return an error.
    pub fn maximum_line_size_bytes(&self) -> Result<NonZeroU32, Error> {
        let bytes = Byte::from_str(&self.maximum_line_size_bytes)?;
        Ok(NonZeroU32::new(u32::try_from(bytes.get_bytes())?)
            .expect("maximum_line_size_bytes must not be 0"))
    }

    /// Determine the `bytes_per_second` for this [`LogTargetTemplate`]
    ///
    /// Parses the user's supplied stringy number into a non-zero u32 of bytes.
    ///
    /// # Errors
    ///
    /// If the users supplies anything other than a stringy number plus some
    /// recognizable unit this function will return an error. Likewise if the
    /// user supplies a number that is larger than `u32::MAX` bytes this
    /// function will return an error.
    pub fn bytes_per_second(&self) -> Result<NonZeroU32, Error> {
        let bytes = Byte::from_str(&self.bytes_per_second)?;
        Ok(NonZeroU32::new(u32::try_from(bytes.get_bytes())?)
            .expect("bytes_per_second must not be 0"))
    }

    /// Determine the `maximum_bytes_per_file` for this [`LogTargetTemplate`]
    ///
    /// Parses the user's supplied stringy number into a non-zero u32 of bytes.
    ///
    /// # Errors
    ///
    /// If the users supplies anything other than a stringy number plus some
    /// recognizable unit this function will return an error. Likewise if the
    /// user supplies a number that is larger than `u32::MAX` bytes this
    /// function will return an error.
    pub fn maximum_bytes_per_file(&self) -> Result<NonZeroU32, Error> {
        let bytes = Byte::from_str(&self.maximum_bytes_per_file)?;
        Ok(NonZeroU32::new(u32::try_from(bytes.get_bytes())?)
            .expect("maximum_bytes_per_file must not be 0"))
    }
}
