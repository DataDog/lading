id: payload-cache-inline
target: lading_payload/src/block.rs:Cache
technique: inline
date: 2026-01-20
status: success
verdict: approved
votes:
  duplicate_hunter: approve
  skeptic: approve
  conservative: approve
  rust_expert: approve
  greybeard: approve
measurements:
  benchmarks:
    micro:
      cache_time: -7.2%
    macro:
      time: 6.9 ms -> 6.4 ms (-7.2%)
      memory: ~0%
      allocations: ~0%
reason: |
  Added #[inline] attributes to five Cache methods (handle, total_size, peek_next_size,
  peek_next_metadata, advance) to enable cross-crate inlining. These are small, hot-path
  methods called 23+ times across 11 generator files.

  Without #[inline], Rust cannot inline public methods across crate boundaries, forcing
  function call overhead on every generator iteration. The advance() method is particularly
  critical, called for every block transmitted.

  All five personas approved unanimously:
  - Duplicate Hunter: Confirmed new optimization, no duplicates
  - Skeptic: 7.2% time improvement with statistical significance (6.914ms -> 6.413ms)
  - Conservative: ci/validate passed, determinism preserved, no semantic changes
  - Rust Expert: Standard Rust performance practice, follows lading patterns
  - Greybeard: Minimal change (5 one-line additions), justified by 7.2% improvement

  Kani proofs ran successfully (no harnesses exist, which is acceptable).
lessons: |
  Cross-crate inlining in Rust requires explicit #[inline] attributes on public methods.
  The compiler cannot inline across crate boundaries without this hint, even for trivial
  methods. This optimization pattern is particularly valuable for:

  1. Small accessor methods (1-3 lines)
  2. Methods called in hot loops
  3. Public APIs in library crates consumed by application crates

  The 7.2% improvement came from eliminating just 5 function call overheads, demonstrating
  that cross-crate call overhead is non-trivial. The 58% reduction in variance suggests
  more predictable performance.

  Key principle: When optimizing library crates, always consider cross-crate call patterns,
  not just within-crate optimizations.
